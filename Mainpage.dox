/**
\mainpage Okular, the unified document viewer

\section okular_overview Overview

- \ref okular_history
- \ref okular_design
- \ref okular_generators
- <a href="http://www.okular.org">Website</a>

\authors Tobias KÃ¶nig <tokoe@kde.org>

\licenses \lgpl

\page okular_history Historical background

Okular is the successor of <a href="kpdf.kde.org">kpdf</a>, the PDF viewer in KDE 3.
kpdf was refactored and extended in a Google Summer of Code project to support not only
viewing PDF but also other types of document, e.g. PostScript files, images and many more.

\page okular_design The Design of Okular

To support a wide range of document formats, Okular was designed in a modular way, so you
have the following components:

  \li \ref Shell
  \li \ref Part
  \li \ref Okular::Document Class
  \li \ref Okular::Generator

The shell is the application which is started by the user as standalone application and
which embedds the part. The part contains all gui elements of Okular, for example the
content list, the bookmark manager, menus and the graphical view of the document class.
The document class is an abstract presentation of the document content. It contains information
about every page of the document, its size, orientation etc.

But somehow the document class must retrieve these information from the various types of documents.
This is the task of the Generators. Generators are plugins which are loaded at runtime and which
have the knowledge about the internal structure of the different document types.
They extract the needed information from the documents, convert the data into a common format and
pass them to the document class.

Currently Generators for the following document types are available:

  \li Portable Document Format (PDF)
  \li PostScript
  \li Device Independent Format (DVI)
  \li DeJaVu Format
  \li Comic Books
  \li Images (JPEG, PNG, GIF, and many more)
  \li TIFF Image Format
  \li FictionBook Format
  \li Plucker Format
  \li OpenDocument Text Format
  \li Microsofts CHM Format
  \li Microsofts XML Document Format

Now the questions is how can these various formats be represented in a unified way?
Okular provides features like rotation, text search and extraction, zooming and many more, so how
does it match with the different capabilities of the formats?

\section okular_design_basics Basics of Generators

Lets start with the smallest commonness of all document formats:

  \li they have pages (one ore more) of a given size
  \li pages can be represented as pictures

So the first thing every Generator must support is to return the number of pages of a document.
Furthermore it must be able to return the picture of a page at a requested size.

For vector based document formats (e.g. PDF or PostScript) the Generators can render the page for
the requested size, for static documents formats (e.g. images), the Generator must scale the
content according to the requested size, so when you zoom a page in Okular, the Generators are
just asked to return the page for the zoomed size.

When the document class has retrieved the page pictures from the Generators, it can do further
image manipulation on it, for example rotating them or applying fancy effects.

\section okular_design_text_support Generators with Text support

Some document formats however support more functionality than just representing a page as an image.
PDF, PostScript, DVI and DeJaVu for example contains a machine readable representation of the
included text. For those document formats Okular provides additional features like text search,
text extraction and text selection.

How is that supported by the Generators?

To access the text from the documents the generators must extract it somehow and make it available
to the document class. However for the text selection feature the document class must also know <em>where</em>
the extracted text is located on the page. For a zoom factor of 100% the absolute position of
the text in the document can be used, however for larger or smaller zoom factors the position
must be recalculated. To make this calculation as easy as possible, the Generators return an
abstract represtentation (\ref Okular::TextPage) of the text which includes every character together
with its <em>normalized</em> position. Normalized means that the width and height of the page is
in the range of 0 to 1, so a character in the middle of the page is at x=0.5 and y=0.5.

So when you want to know where this character is located on the page which is zoomed at 300%, you just
multiply the position by 3 * page width (and page height) and get the absolute position for this zoom level.

This abstract text representation also allows an easy rotation of the coordinates, so that text selection
is available on rotated pages as well.

\section okular_design_meta_information Meta Information

Most documents have additional meta information like the name of the author, date of creation,
version number etc. These information can be retrieved by the generator as well and will be
shown by Okular in the document properties dialog.

\page okular_generators How to implement a Generator

The power of Okular is its extensibility by Generator plugins. This section will describe how to
implement your own plugin for a new document type.

\section okular_generators_basic A Basic Generator

To provide a short overview and don't reimplementing an existing generator we'll work on a Generator
for the Magic document format, a non existing, pure virtual format :)

Lets assume we have some helper class (MagicDocument) which provides the following functionality for this
document format:

 \li Loading a document
 \li Retrieving number of pages
 \li Returning a fixed size picture representation of a page

The class API looks like this

\code
class MagicDocument
{
    public:
        MagicDocument();
        ~MagicDocument();

        bool loadDocument( const QString &fileName );

        int numberOfPages() const;

        QSize pageSize( int pageNumber ) const;

        QImage pictureOfPage( int pageNumber ) const;

    private:
        ...
};
\endcode

The methods should be self explaining, loadDocument() loads a document file and returns false on error,
numberOfPages() returns the number of pages, pageSize() returns the size of the page and pictureOfPage()
returns the picture representation of the page.

Our first version of our Generator is a basic one which just provides page pictures to the document class.

The API of the Generator looks like the following:

\code
#include "magicdocument.h"

#include <okular/core/generator.h>

class MagicGenerator : public Okular::Generator
{
    public:
        MagicGenerator();
        ~MagicGenerator();

        bool loadDocument( const QString &fileName, QVector<Okular::Page*> &pages );
        bool closeDocument();

        bool canGeneratePixmap() const;
        void generatePixmap( Okular::PixmapRequest *request );

    private:
        MagicDocument mMagicDocument;
};
\endcode

The implementation of the Generator looks like this:

\code
#include <okular/core/page.h>

#include "magicgenerator.h"

OKULAR_EXPORT_PLUGIN(MagicGenerator)

MagicGenerator::MagicGenerator()
    : Generator()
{
}

MagicGenerator::~MagicGenerator()
{
}

bool MagicGenerator::loadDocument( const QString &fileName, QVector<Okular::Page*> &pages )
{
    if ( !mMagicDocument.loadDocument( fileName ) ) {
        emit error( i18n( "Unable to load document" ), -1 );
        return false;
    }

    pagesVector.resize( mMagicDocument.numberOfPages() );

    for ( int i = 0; i < mMagicDocument.numberOfPages(); ++i ) {
      const QSize size = mMagicDocument.pageSize( i );

      Okular::Page * page = new Okular::Page( i, size.width(), size.height(), Okular::Rotation0 );
      pages[ i ] = page;
    }

    return true;
}

bool MagicGenerator::closeDocument()
{
    return true;
}

bool MagicGenerator::canGeneratePixmap() const
{
    return true;
}

void MagicGenerator::generatePixmap( Okular::PixmapRequest *request )
{
    QImage image = mMagicDocument.pictureOfPage( request->pageNumber() );

    image = image.scaled( request->width(), request->height(), Qt::IgnoreAspectRatio, Qt::SmoothTransformation );

    request->page()->setPixmap( request->id(), new QPixmap( QPixmap::fromImage( image ) ) );

    signalPixmapRequestDone( request );
}

\endcode

As you can see implementing a basic Generator is quite easy. The loadDocument() method opens the document file
and extracts the number of pages. For every page in the document it adds an Okular::Page object to the pages vector
which is passed in as method argument. Each page is initialized with its page number, width, height and initial rotation.
These page objects will be stored in the document object and act as a container for the picture representation
of the pages. This code is the same for nearly every Generator. On an failure the error() signal can be emitted
to inform the user about the issue. This code is the same for nearly every Generator.

In the closeDocument() method you should close the document and free all resources you have allocated in openDocument().

Now we come to the picture creation methods. The canGeneratorPixmap() method returns whether the Generator is currently
able to handle a new pixmap generation request. For a simple Generator like our one that's always the case as it works
linear, however a multithreaded Generator might return <em>false</em> here if it is still waiting for one of its working
threads to finish. In this case the document class will try to request the pixmap later again.

The generatePixmap() method does the actual fetching of the picture for a page. The page number, requested width and
height of the page is encapsulated in the passed Okular::PixmapRequest object.
So the task of the Generator is to create a pixmap of the requested page in the requested size and then store this
pixmap in the Okular::Page object which is associated with the page request.
When this task is finished, the Generator has to call signalPixmapRequestDone() with the page request object
as argument. This extra call is needed to allow the Generator to use signals and slots internally and create the
pixmap asynchronously.

So now you have the code of a working Okular Generator, the next step is to tell Okular about the new plugin.
Like in other places in KDE that is done by .desktop files, which are installed to the services directory.

Every Generator needs 3 .desktop files:

  \li libokularGenerator_&lt;name&gt;.desktop
  \li okularApplication_&lt;name&gt;.desktop
  \li okular&lt;name&gt;.desktop

where &lt;name&gt; should be the name of the document format. So for our Magic Document Generator we
create the following 3 files:

  \li libokularGenerator_magic.desktop
  \li okularApplication_magic.desktop
  \li okularMagic.desktop

with the following content:

\verbatim
[Desktop Entry]
Encoding=UTF-8
Type=Service
Name=Magic Document
Name[x-test]=xxMagic Documentxx
Comment=Magic Document backend for okular
Comment[x-test]=xxMagic Document backend for okularxx
ServiceTypes=okular/Generator
MimeType=application/x-magic
X-KDE-Library=libokularGenerator_magic
X-KDE-Priority=1
X-KDE-okularAPIVersion=1
X-KDE-okularHasInternalSettings=false
\endverbatim

The first 6 fields are standard .desktop entries, the fields afterwards have a special meaning to Okular

  \li <b>ServiceType</b>  Must be 'okular/Generator' for all Okular Generator Plugins
  \li <b>MimeType</b> The mimetype or list of mimetypes of the supported document format(s)
  \li <b>X-KDE-Library</b> The name of the plugin library
  \li <b>X-KDE-Priority</b> When multiple Generators for the same mimetype exists, the one with the highest priority is used
  \li <b>X-KDE-okularAPIVersion</b> The version of the Generator Plugin API ('1' currently)
  \li <b>X-KDE-okularHasInternalSettings</b> Is 'true' when the Generator provides configuration dialogs

The second .desktop file has the following content:

\verbatim
[Desktop Entry]
Encoding=UTF-8
MimeType=application/x-magic;
Terminal=false
Name=okular
Name[x-test]=xxokularxx
GenericName=Document Viewer
GenericName[x-test]=xxDocument Viewerxx
Exec=okular %U %i -caption "%c"
Icon=okular
Type=Application
DocPath=okular/index.html
InitialPreference=7
Categories=Qt;KDE;Graphics;Viewer;
NoDisplay=true
\endverbatim

You can use the file as it is, you just have to adapt the mimetype. This file is needed to allow Okular
to handle multiple mimetypes.

The third .desktop file looks like this:

\verbatim
[Desktop Entry]
Encoding=UTF-8
Icon=okular
Name=okular
Name[x-test]=xxokularxx
ServiceTypes=KParts/ReadOnlyPart
X-KDE-Library=libokularpart
Type=Service
MimeType=application/x-magic
\endverbatim

You can use the file as it is as well, you just have to adapt the mimetype. This file is needed to allow
the Okular part to handle multiple mimetypes.

The last piece you need for a complete Generator is a CMakeLists.txt which compiles and installs the
Generator. Our CMakeLists.txt looks like the following:

\verbatim
macro_optional_find_package(Okular)

include_directories( ${OKULAR_INCLUDE_DIR} ${KDE4_INCLUDE_DIR} ${QT_INCLUDES} )

########### next target ###############

set( okularGenerator_magic_SRCS generator_magic.cpp )

kde4_automoc( ${okularGenerator_magic_SRCS} )

kde4_add_plugin( okularGenerator_magic WITH_PREFIX ${okularGenerator_magic_SRCS} )

target_link_libraries( okularGenerator_magic ${OKULAR_LIBRARIES} ${KDE4_KDEUI_LIBS} )

install( TARGETS okularGenerator_magic DESTINATION ${PLUGIN_INSTALL_DIR} )

########### install files ###############

install( FILES libokularGenerator_magic.desktop okularMagic.desktop DESTINATION ${SERVICES_INSTALL_DIR} )
install( FILES okularApplication_magic.desktop DESTINATION ${XDG_APPS_DIR} )
\endverbatim

The macro_optional_find_package(Okular) call is required to make the ${OKULAR_INCLUDE_DIR} and ${OKULAR_LIBRARIES}
variables available.

Now you can compile the Generator plugin and install it. After a restart of Okular the new plugin is available
and you can open Magic documents.

\section okular_generators_with_text A Generator with TextPage support

\code
#include "magicdocument.h"

#include <okular/core/generator.h>

class MagicGenerator : public Okular::Generator
{
    public:
        MagicGenerator();
        ~MagicGenerator();

        bool loadDocument( const QString &fileName, QVector<Okular::Page*> &pages );
        bool closeDocument();

        bool canGeneratePixmap() const;
        void generatePixmap( Okular::PixmapRequest *request );

    private:
        MagicDocument mMagicDocument;
};
\endcode

*/
